// pages/api/ask.js
import fs from 'fs';
import path from 'path';

// ==================== FONCTION DE SAUVEGARDE DES LOGS ====================
function saveToLogs(question, answer, model) {
  try {
    // Cr√©er un timestamp d√©taill√©
    const now = new Date();
    const timestamp = now.toISOString(); // Format: 2024-11-05T14:30:45.123Z
    
    // Cr√©er l'objet log
    const logEntry = {
      timestamp: timestamp,
      date: now.toLocaleDateString('fr-FR'),
      time: now.toLocaleTimeString('fr-FR', { 
        hour: '2-digit', 
        minute: '2-digit', 
        second: '2-digit',
        fractionalSecondDigits: 3  // millisecondes
      }),
      question: question,
      answer: answer,
      model: model
    };

    // Chemin du fichier logs
    const logsDir = path.join(process.cwd(), 'logs');
    const logsFile = path.join(logsDir, 'conversations.json');

    // Cr√©er le dossier logs s'il n'existe pas
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }

    // Lire les logs existants ou cr√©er un tableau vide
    let logs = [];
    if (fs.existsSync(logsFile)) {
      const fileContent = fs.readFileSync(logsFile, 'utf8');
      logs = JSON.parse(fileContent);
    }

    // Ajouter le nouveau log
    logs.push(logEntry);

    // Sauvegarder dans le fichier
    fs.writeFileSync(logsFile, JSON.stringify(logs, null, 2), 'utf8');

    console.log("üíæ Log sauvegard√©:", logsFile);

  } catch (error) {
    console.error("‚ùå Erreur sauvegarde logs:", error.message);
  }
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { question } = req.body;

  if (!question || question.trim() === "") {
    return res.status(400).json({ error: "No question provided" });
  }

  try {
    console.log("üîë Cl√© API pr√©sente:", !!process.env.HF_API_KEY);
    console.log("‚ùì Question:", question);
    console.log("ü§ñ Mod√®le: MiniMaxAI/MiniMax-M2");

    // Nouvelle API Hugging Face (format OpenAI-compatible)
    const response = await fetch(
      "https://router.huggingface.co/v1/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${process.env.HF_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "MiniMaxAI/MiniMax-M2",
          messages: [
            {
              role: "system",
              content: "Tu es un assistant utile qui r√©pond de mani√®re claire et pr√©cise en fran√ßais."
            },
            {
              role: "user",
              content: question
            }
          ],
          max_tokens: 2000,  // Augment√© pour des r√©ponses compl√®tes
          temperature: 0.7,
          stream: false
        }),
      }
    );

    console.log("üì° Status HTTP:", response.status);

    // Lire la r√©ponse
    const data = await response.json();
    console.log("üì¶ R√©ponse compl√®te:", JSON.stringify(data, null, 2));

    // V√©rifier les erreurs
    if (!response.ok || data.error) {
      console.error("‚ùå Erreur API:", data.error || response.statusText);
      
      // Si le mod√®le n'est pas disponible, essayer un mod√®le alternatif
      if (response.status === 404 || response.status === 403) {
        console.log("‚ö†Ô∏è MiniMax-M2 non disponible, essai d'un mod√®le alternatif...");
        return await tryAlternativeModel(question, res);
      }
      
      throw new Error(data.error?.message || data.error || `HTTP ${response.status}`);
    }

    // Extraire la r√©ponse (format OpenAI)
    const answer = data.choices?.[0]?.message?.content;

    if (!answer || answer.trim() === "") {
      console.warn("‚ö†Ô∏è Aucune r√©ponse g√©n√©r√©e");
      throw new Error("Aucune r√©ponse g√©n√©r√©e par le mod√®le");
    }

    console.log("‚úÖ R√©ponse brute:", answer);

    // Nettoyer la r√©ponse (enlever les balises <think>)
    let cleanAnswer = answer.trim();
    
    // Supprimer les balises <think>...</think>
    cleanAnswer = cleanAnswer.replace(/<think>[\s\S]*?<\/think>/g, '').trim();
    
    // Supprimer d'autres balises potentielles
    cleanAnswer = cleanAnswer.replace(/<[^>]+>/g, '').trim();

    console.log("‚úÖ R√©ponse nettoy√©e:", cleanAnswer);

    // Sauvegarder dans un fichier JSON
    saveToLogs(question, cleanAnswer, "MiniMaxAI/MiniMax-M2");

    return res.status(200).json({ 
      answer: cleanAnswer,
      model: "MiniMaxAI/MiniMax-M2"
    });

  } catch (error) {
    console.error("üí• Erreur:", error.message);

    return res.status(500).json({ 
      error: "Erreur du mod√®le",
      message: error.message,
      answer: `‚ö†Ô∏è D√©sol√©, je ne peux pas r√©pondre pour le moment. ${error.message}`
    });
  }
}

// Fonction pour essayer un mod√®le alternatif si MiniMax-M2 n'est pas disponible
async function tryAlternativeModel(question, res) {
  try {
    console.log("üîÑ Essai avec meta-llama/Llama-3.3-70B-Instruct...");
    
    const response = await fetch(
      "https://router.huggingface.co/v1/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${process.env.HF_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "meta-llama/Llama-3.3-70B-Instruct",
          messages: [
            {
              role: "system",
              content: "Tu es un assistant utile qui r√©pond de mani√®re claire et pr√©cise en fran√ßais."
            },
            {
              role: "user",
              content: question
            }
          ],
          max_tokens: 2000,  // Augment√© pour des r√©ponses compl√®tes
          temperature: 0.7,
          stream: false
        }),
      }
    );

    const data = await response.json();
    console.log("üì¶ R√©ponse Llama:", JSON.stringify(data, null, 2));

    if (response.ok && data.choices?.[0]?.message?.content) {
      let answer = data.choices[0].message.content.trim();
      
      // Nettoyer les balises <think>
      answer = answer.replace(/<think>[\s\S]*?<\/think>/g, '').trim();
      answer = answer.replace(/<[^>]+>/g, '').trim();
      
      console.log("‚úÖ Succ√®s avec Llama-3.3!");

      // Sauvegarder dans les logs
      saveToLogs(question, answer, "meta-llama/Llama-3.3-70B-Instruct (fallback)");
      
      return res.status(200).json({ 
        answer: answer,
        model: "meta-llama/Llama-3.3-70B-Instruct (fallback)",
        note: "MiniMax-M2 n'√©tait pas disponible, Llama-3.3 a √©t√© utilis√© √† la place."
      });
    }

    throw new Error("Mod√®le alternatif aussi indisponible");

  } catch (altError) {
    console.error("üí• Erreur mod√®le alternatif:", altError.message);
    
    return res.status(500).json({ 
      error: "Tous les mod√®les sont indisponibles",
      message: "Veuillez r√©essayer plus tard ou utiliser une autre API (comme Groq).",
      answer: "‚ö†Ô∏è D√©sol√©, tous les mod√®les IA sont temporairement indisponibles."
    });
  }
}